'use strict'
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = 'vendor-chunks/@lexical+list@0.35.0'
exports.ids = ['vendor-chunks/@lexical+list@0.35.0']
exports.modules = {
  /***/ '(rsc)/../node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs':
    /*!*************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs ***!
  \*************************************************************************************************/
    /***/ (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
      eval(
        "__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createListItemNode: () => (/* binding */ $createListItemNode),\n/* harmony export */   $createListNode: () => (/* binding */ $createListNode),\n/* harmony export */   $getListDepth: () => (/* binding */ $getListDepth),\n/* harmony export */   $handleListInsertParagraph: () => (/* binding */ $handleListInsertParagraph),\n/* harmony export */   $insertList: () => (/* binding */ $insertList),\n/* harmony export */   $isListItemNode: () => (/* binding */ $isListItemNode),\n/* harmony export */   $isListNode: () => (/* binding */ $isListNode),\n/* harmony export */   $removeList: () => (/* binding */ $removeList),\n/* harmony export */   INSERT_CHECK_LIST_COMMAND: () => (/* binding */ INSERT_CHECK_LIST_COMMAND),\n/* harmony export */   INSERT_ORDERED_LIST_COMMAND: () => (/* binding */ INSERT_ORDERED_LIST_COMMAND),\n/* harmony export */   INSERT_UNORDERED_LIST_COMMAND: () => (/* binding */ INSERT_UNORDERED_LIST_COMMAND),\n/* harmony export */   ListItemNode: () => (/* binding */ ListItemNode),\n/* harmony export */   ListNode: () => (/* binding */ ListNode),\n/* harmony export */   REMOVE_LIST_COMMAND: () => (/* binding */ REMOVE_LIST_COMMAND),\n/* harmony export */   UPDATE_LIST_START_COMMAND: () => (/* binding */ UPDATE_LIST_START_COMMAND),\n/* harmony export */   insertList: () => (/* binding */ insertList),\n/* harmony export */   registerCheckList: () => (/* binding */ registerCheckList),\n/* harmony export */   registerList: () => (/* binding */ registerList),\n/* harmony export */   registerListStrictIndentTransform: () => (/* binding */ registerListStrictIndentTransform),\n/* harmony export */   removeList: () => (/* binding */ removeList)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/../node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/../node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/../node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n          const listItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestNodeOfType)(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandparent)) {\n    replacementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node);\n  }\n  extractWithChild(child, selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !($isListNode(node) || node.isInline()) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.calculateZoomLevel)(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(event.target)) {\n      const domNode = event.target;\n      const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getNearestEditorFromDOMNode)(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK2xpc3RAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saXN0L0xleGljYWxMaXN0LmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUw7QUFDdVc7QUFDL2Q7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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S0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxVQUFVLHVEQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseURBQWdCO0FBQ3BEO0FBQ0E7QUFDQSxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkVBQTJCO0FBQy9CO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZ0RBQVc7QUFDbEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGVBQWUsZ0RBQVc7QUFDMUIsaUJBQWlCLHVEQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QVUsMERBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLDZDQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtRUFBbUI7QUFDcEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4WSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxWSVRBXFxOZXh0anNcXHBheWxvYWQtcGx1Z2luc1xcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGxleGljYWwrbGlzdEAwLjM1LjBcXG5vZGVfbW9kdWxlc1xcQGxleGljYWxcXGxpc3RcXExleGljYWxMaXN0LmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgbWVyZ2VSZWdpc3RlciwgJGZpbmRNYXRjaGluZ1BhcmVudCwgY2FsY3VsYXRlWm9vbUxldmVsIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkaXNFbGVtZW50Tm9kZSwgJGlzTGVhZk5vZGUsICRzZXRQb2ludEZyb21DYXJldCwgJG5vcm1hbGl6ZUNhcmV0LCAkZ2V0Q2hpbGRDYXJldCwgRWxlbWVudE5vZGUsIGJ1aWxkSW1wb3J0TWFwLCAkaXNQYXJhZ3JhcGhOb2RlLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsICRjcmVhdGVUZXh0Tm9kZSwgY3JlYXRlQ29tbWFuZCwgQ09NTUFORF9QUklPUklUWV9MT1csIEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIEtFWV9BUlJPV19VUF9DT01NQU5ELCBLRVlfRVNDQVBFX0NPTU1BTkQsIEtFWV9TUEFDRV9DT01NQU5ELCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlLCAkZ2V0Tm9kZUJ5S2V5LCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICRpc1RleHROb2RlLCBUZXh0Tm9kZSB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgZ2V0U3R5bGVPYmplY3RGcm9tQ1NTIH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIENoZWNrcyB0aGUgZGVwdGggb2YgbGlzdE5vZGUgZnJvbSB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGxpc3ROb2RlIC0gVGhlIExpc3ROb2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUaGUgZGVwdGggb2YgdGhlIExpc3ROb2RlLlxuICovXG5mdW5jdGlvbiAkZ2V0TGlzdERlcHRoKGxpc3ROb2RlKSB7XG4gIGxldCBkZXB0aCA9IDE7XG4gIGxldCBwYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnQoKTtcbiAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBwYXJlbnRMaXN0ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudExpc3QpKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudExpc3QuZ2V0UGFyZW50KCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEEgTGlzdEl0ZW1Ob2RlIG11c3QgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlcHRoO1xuICB9XG4gIHJldHVybiBkZXB0aDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbmVhcmVzdCBhbmNlc3RyYWwgTGlzdE5vZGUgYW5kIHJldHVybnMgaXQsIHRocm93cyBhbiBpbnZhcmlhbnQgaWYgbGlzdEl0ZW0gaXMgbm90IGEgTGlzdEl0ZW1Ob2RlLlxuICogQHBhcmFtIGxpc3RJdGVtIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRoZSBMaXN0Tm9kZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gJGdldFRvcExpc3ROb2RlKGxpc3RJdGVtKSB7XG4gIGxldCBsaXN0ID0gbGlzdEl0ZW0uZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEEgTGlzdEl0ZW1Ob2RlIG11c3QgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5gKTtcbiAgICB9XG4gIH1cbiAgbGV0IHBhcmVudCA9IGxpc3Q7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgIGxpc3QgPSBwYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEEgcmVjdXJzaXZlIERlcHRoLUZpcnN0IFNlYXJjaCAoUG9zdG9yZGVyIFRyYXZlcnNhbCkgdGhhdCBmaW5kcyBhbGwgb2YgYSBub2RlJ3MgY2hpbGRyZW5cbiAqIHRoYXQgYXJlIG9mIHR5cGUgTGlzdEl0ZW1Ob2RlIGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXkuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBMaXN0Tm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyBhbGwgbm9kZXMgb2YgdHlwZSBMaXN0SXRlbU5vZGUgZm91bmQuXG4gKi9cbi8vIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlICRnZXRBbGxDaGlsZHJlbk9mVHlwZVxuZnVuY3Rpb24gJGdldEFsbExpc3RJdGVtcyhub2RlKSB7XG4gIGxldCBsaXN0SXRlbU5vZGVzID0gW107XG4gIGNvbnN0IGxpc3RDaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKS5maWx0ZXIoJGlzTGlzdEl0ZW1Ob2RlKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSBsaXN0Q2hpbGRyZW5baV07XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICBsaXN0SXRlbU5vZGVzID0gbGlzdEl0ZW1Ob2Rlcy5jb25jYXQoJGdldEFsbExpc3RJdGVtcyhmaXJzdENoaWxkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3RJdGVtTm9kZXMucHVzaChsaXN0SXRlbU5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdEl0ZW1Ob2Rlcztcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBwYXNzZWQgbm9kZSBpcyBhIExpc3RJdGVtTm9kZSBhbmQgaGFzIGEgTGlzdE5vZGUgYXMgYSBjaGlsZC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUgYW5kIGhhcyBhIExpc3ROb2RlIGNoaWxkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTmVzdGVkTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmICRpc0xpc3ROb2RlKG5vZGUuZ2V0Rmlyc3RDaGlsZCgpKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIGRlZXBseSBuZXN0ZWQgTGlzdE5vZGUgb3IgTGlzdEl0ZW1Ob2RlIGFuZCB0cmF2ZXJzZXMgdXAgdGhlIGJyYW5jaCB0byBkZWxldGUgdGhlIGZpcnN0XG4gKiBhbmNlc3RyYWwgTGlzdE5vZGUgKHdoaWNoIGNvdWxkIGJlIHRoZSByb290IExpc3ROb2RlKSBvciBMaXN0SXRlbU5vZGUgd2l0aCBzaWJsaW5ncywgZXNzZW50aWFsbHlcbiAqIGJyaW5naW5nIHRoZSBkZWVwbHkgbmVzdGVkIG5vZGUgdXAgdGhlIGJyYW5jaCBvbmNlLiBXb3VsZCByZW1vdmUgc3VibGlzdCBpZiBpdCBoYXMgc2libGluZ3MuXG4gKiBTaG91bGQgbm90IGJyZWFrIExpc3RJdGVtIC0+IExpc3QgLT4gTGlzdEl0ZW0gY2hhaW4gYXMgZW1wdHkgTGlzdC9JdGVtTm9kZXMgc2hvdWxkIGJlIHJlbW92ZWQgb24gLnJlbW92ZSgpLlxuICogQHBhcmFtIHN1Ymxpc3QgLSBUaGUgbmVzdGVkIExpc3ROb2RlIG9yIExpc3RJdGVtTm9kZSB0byBiZSBicm91Z2h0IHVwIHRoZSBicmFuY2guXG4gKi9cbmZ1bmN0aW9uICRyZW1vdmVIaWdoZXN0RW1wdHlMaXN0UGFyZW50KHN1Ymxpc3QpIHtcbiAgLy8gTm9kZXMgbWF5IGJlIHJlcGVhdGVkbHkgaW5kZW50ZWQsIHRvIGNyZWF0ZSBkZWVwbHkgbmVzdGVkIGxpc3RzIHRoYXQgZWFjaFxuICAvLyBjb250YWluIGp1c3Qgb25lIGJ1bGxldC5cbiAgLy8gT3VyIGdvYWwgaXMgdG8gcmVtb3ZlIHRoZXNlIChlbXB0eSkgZGVlcGx5IG5lc3RlZCBsaXN0cy4gVGhlIGVhc2llc3RcbiAgLy8gd2F5IHRvIGRvIHRoYXQgaXMgY3Jhd2wgYmFjayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgbm9kZSB0aGF0IGhhcyBzaWJsaW5nc1xuICAvLyAoZS5nLiBpcyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGNvbnRlbnRzKSBhbmQgZGVsZXRlIHRoYXQsIG9yIGRlbGV0ZVxuICAvLyB0aGUgcm9vdCBvZiB0aGUgbGlzdCAoaWYgbm8gbGlzdCBub2RlcyBoYXZlIHNpYmxpbmdzLilcbiAgbGV0IGVtcHR5TGlzdFB0ciA9IHN1Ymxpc3Q7XG4gIHdoaWxlIChlbXB0eUxpc3RQdHIuZ2V0TmV4dFNpYmxpbmcoKSA9PSBudWxsICYmIGVtcHR5TGlzdFB0ci5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PSBudWxsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZW1wdHlMaXN0UHRyLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT0gbnVsbCB8fCAhKCRpc0xpc3RJdGVtTm9kZShwYXJlbnQpIHx8ICRpc0xpc3ROb2RlKHBhcmVudCkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZW1wdHlMaXN0UHRyID0gcGFyZW50O1xuICB9XG4gIGVtcHR5TGlzdFB0ci5yZW1vdmUoKTtcbn1cblxuLyoqXG4gKiBXcmFwcyBhIG5vZGUgaW50byBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgd3JhcHBlZCBpbnRvIGEgTGlzdEl0ZW1Ob2RlXG4gKiBAcmV0dXJucyBUaGUgTGlzdEl0ZW1Ob2RlIHdoaWNoIHRoZSBwYXNzZWQgbm9kZSBpcyB3cmFwcGVkIGluLlxuICovXG5mdW5jdGlvbiAkd3JhcEluTGlzdEl0ZW0obm9kZSkge1xuICBjb25zdCBsaXN0SXRlbVdyYXBwZXIgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gIHJldHVybiBsaXN0SXRlbVdyYXBwZXIuYXBwZW5kKG5vZGUpO1xufVxuXG5mdW5jdGlvbiAkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSB7XG4gIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkgJiYgKG5vZGVzLmxlbmd0aCA9PT0gMCB8fCBub2Rlcy5sZW5ndGggPT09IDEgJiYgYW5jaG9yTm9kZS5pcyhub2Rlc1swXSkgJiYgYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCk7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBMaXN0Tm9kZS4gSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZSBhbmQgaXMgYSBjaGlsZCBvZlxuICogdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgcmVwbGFjZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpdGggYSBMaXN0Tm9kZSBhbmQgdGhlIG9sZCBMaXN0SXRlbU5vZGUuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCByZXBsYWNlIGl0cyBwYXJlbnQgd2l0aCBhIG5ldyBMaXN0Tm9kZSBhbmQgcmUtaW5zZXJ0IHRoZSBMaXN0SXRlbU5vZGUgYW5kIGFueSBwcmV2aW91cyBjaGlsZHJlbi5cbiAqIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBub3QgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlLCBpdCB3aWxsIGFkZCBhIG5ldyBMaXN0Tm9kZSBvciBtZXJnZSBhbiBleGlzdGluZyBMaXN0Tm9kZSxcbiAqIHVubGVzcyB0aGUgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBMaXN0Tm9kZSB1cCB0aGUgYnJhbmNoIGFuZCByZXBsYWNlIGl0IHdpdGhcbiAqIGEgbmV3IExpc3ROb2RlLCBvciBjcmVhdGUgYSBuZXcgTGlzdE5vZGUgYXQgdGhlIG5lYXJlc3Qgcm9vdC9zaGFkb3cgcm9vdC5cbiAqIEBwYXJhbSBsaXN0VHlwZSAtIFRoZSB0eXBlIG9mIGxpc3QsIFwibnVtYmVyXCIgfCBcImJ1bGxldFwiIHwgXCJjaGVja1wiLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0TGlzdChsaXN0VHlwZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBsZXQgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgICAgIGlmICghKGFuY2hvckFuZEZvY3VzICE9PSBudWxsKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluc2VydExpc3Q6IGFuY2hvciBzaG91bGQgYmUgZGVmaW5lZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgW2FuY2hvcl0gPSBhbmNob3JBbmRGb2N1cztcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZVBhcmVudCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChhbmNob3JOb2RlKSkge1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gYW5jaG9yTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgICAgbm9kZXMgPSBmaXJzdENoaWxkLnNlbGVjdFN0YXJ0KCkuZ2V0Tm9kZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgIGFuY2hvck5vZGUuYXBwZW5kKHBhcmFncmFwaCk7XG4gICAgICAgICAgbm9kZXMgPSBwYXJhZ3JhcGguc2VsZWN0KCkuZ2V0Tm9kZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSkge1xuICAgICAgICBjb25zdCBsaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZVBhcmVudCkpIHtcbiAgICAgICAgICBhbmNob3JOb2RlLnJlcGxhY2UobGlzdCk7XG4gICAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICBsaXN0SXRlbS5zZXRGb3JtYXQoYW5jaG9yTm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgICAgICAgbGlzdEl0ZW0uc2V0SW5kZW50KGFuY2hvck5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaXN0LmFwcGVuZChsaXN0SXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgYXBwZW5kKGxpc3QsIHBhcmVudC5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICBwYXJlbnQucmVwbGFjZShsaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuaXNFbXB0eSgpICYmICEkaXNMaXN0SXRlbU5vZGUobm9kZSkgJiYgIWhhbmRsZWQuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICAgICRjcmVhdGVMaXN0T3JNZXJnZShub2RlLCBsaXN0VHlwZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHBhcmVudCA9ICRpc0xlYWZOb2RlKG5vZGUpID8gbm9kZS5nZXRQYXJlbnQoKSA6ICRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiBub2RlLmlzRW1wdHkoKSA/IG5vZGUgOiBudWxsO1xuICAgICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudC5nZXRLZXkoKTtcbiAgICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICBpZiAoIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xpc3ROb2RlID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgICAgICAgIGFwcGVuZChuZXdMaXN0Tm9kZSwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2UobmV3TGlzdE5vZGUpO1xuICAgICAgICAgICAgaGFuZGxlZC5hZGQocGFyZW50S2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV4dFBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChuZXh0UGFyZW50KSAmJiAhaGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgICAgICAgaGFuZGxlZC5hZGQocGFyZW50S2V5KTtcbiAgICAgICAgICAgICRjcmVhdGVMaXN0T3JNZXJnZShwYXJlbnQsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBuZXh0UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBlbmQobm9kZSwgbm9kZXNUb0FwcGVuZCkge1xuICBub2RlLnNwbGljZShub2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBub2Rlc1RvQXBwZW5kKTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVMaXN0T3JNZXJnZShub2RlLCBsaXN0VHlwZSkge1xuICBpZiAoJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gIGFwcGVuZChsaXN0SXRlbSwgbm9kZS5nZXRDaGlsZHJlbigpKTtcbiAgbGV0IHRhcmdldExpc3Q7XG4gIGlmICgkaXNMaXN0Tm9kZShwcmV2aW91c1NpYmxpbmcpICYmIGxpc3RUeXBlID09PSBwcmV2aW91c1NpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIHByZXZpb3VzU2libGluZy5hcHBlbmQobGlzdEl0ZW0pO1xuICAgIC8vIGlmIHRoZSBzYW1lIHR5cGUgb2YgbGlzdCBpcyBvbiBib3RoIHNpZGVzLCBtZXJnZSB0aGVtLlxuICAgIGlmICgkaXNMaXN0Tm9kZShuZXh0U2libGluZykgJiYgbGlzdFR5cGUgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICAgIGFwcGVuZChwcmV2aW91c1NpYmxpbmcsIG5leHRTaWJsaW5nLmdldENoaWxkcmVuKCkpO1xuICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRhcmdldExpc3QgPSBwcmV2aW91c1NpYmxpbmc7XG4gIH0gZWxzZSBpZiAoJGlzTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGxpc3RUeXBlID09PSBuZXh0U2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKS5pbnNlcnRCZWZvcmUobGlzdEl0ZW0pO1xuICAgIHRhcmdldExpc3QgPSBuZXh0U2libGluZztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICBsaXN0LmFwcGVuZChsaXN0SXRlbSk7XG4gICAgbm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgIHRhcmdldExpc3QgPSBsaXN0O1xuICB9XG4gIC8vIGxpc3RJdGVtIG5lZWRzIHRvIGJlIGF0dGFjaGVkIHRvIHJvb3QgcHJpb3IgdG8gc2V0dGluZyBpbmRlbnRcbiAgbGlzdEl0ZW0uc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgbGlzdEl0ZW0uc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICBub2RlLnJlbW92ZSgpO1xuICByZXR1cm4gdGFyZ2V0TGlzdDtcbn1cblxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGdvZXMgdGhyb3VnaCBlYWNoIGxpc3QgYW5kIHRoZWlyIGNoaWxkcmVuLCBpbmNsdWRpbmcgbmVzdGVkIGxpc3RzLFxuICogYXBwZW5kaW5nIGxpc3QyIGNoaWxkcmVuIGFmdGVyIGxpc3QxIGNoaWxkcmVuIGFuZCB1cGRhdGluZyBMaXN0SXRlbU5vZGUgdmFsdWVzLlxuICogQHBhcmFtIGxpc3QxIC0gVGhlIGZpcnN0IGxpc3QgdG8gYmUgbWVyZ2VkLlxuICogQHBhcmFtIGxpc3QyIC0gVGhlIHNlY29uZCBsaXN0IHRvIGJlIG1lcmdlZC5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VMaXN0cyhsaXN0MSwgbGlzdDIpIHtcbiAgY29uc3QgbGlzdEl0ZW0xID0gbGlzdDEuZ2V0TGFzdENoaWxkKCk7XG4gIGNvbnN0IGxpc3RJdGVtMiA9IGxpc3QyLmdldEZpcnN0Q2hpbGQoKTtcbiAgaWYgKGxpc3RJdGVtMSAmJiBsaXN0SXRlbTIgJiYgaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbTEpICYmIGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW0yKSkge1xuICAgIG1lcmdlTGlzdHMobGlzdEl0ZW0xLmdldEZpcnN0Q2hpbGQoKSwgbGlzdEl0ZW0yLmdldEZpcnN0Q2hpbGQoKSk7XG4gICAgbGlzdEl0ZW0yLnJlbW92ZSgpO1xuICB9XG4gIGNvbnN0IHRvTWVyZ2UgPSBsaXN0Mi5nZXRDaGlsZHJlbigpO1xuICBpZiAodG9NZXJnZS5sZW5ndGggPiAwKSB7XG4gICAgbGlzdDEuYXBwZW5kKC4uLnRvTWVyZ2UpO1xuICB9XG4gIGxpc3QyLnJlbW92ZSgpO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RyYWwgTGlzdE5vZGUgYW5kIHJlbW92ZXMgaXQuIElmIHNlbGVjdGlvbiBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGVcbiAqIGl0IHdpbGwgcmVtb3ZlIHRoZSB3aG9sZSBsaXN0LCBpbmNsdWRpbmcgdGhlIExpc3RJdGVtTm9kZS4gRm9yIGVhY2ggTGlzdEl0ZW1Ob2RlIGluIHRoZSBMaXN0Tm9kZSxcbiAqIHJlbW92ZUxpc3Qgd2lsbCBhbHNvIGdlbmVyYXRlIG5ldyBQYXJhZ3JhcGhOb2RlcyBpbiB0aGUgcmVtb3ZlZCBMaXN0Tm9kZSdzIHBsYWNlLiBBbnkgY2hpbGQgbm9kZVxuICogaW5zaWRlIGEgTGlzdEl0ZW1Ob2RlIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIG5ldyBQYXJhZ3JhcGhOb2Rlcy5cbiAqL1xuZnVuY3Rpb24gJHJlbW92ZUxpc3QoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBsaXN0Tm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgaWYgKCRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpKSB7XG4gICAgICBsaXN0Tm9kZXMuYWRkKCRnZXRUb3BMaXN0Tm9kZShhbmNob3JOb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoJGlzTGVhZk5vZGUobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUobm9kZSwgTGlzdEl0ZW1Ob2RlKTtcbiAgICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxpc3ROb2Rlcy5hZGQoJGdldFRvcExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpc3ROb2RlIG9mIGxpc3ROb2Rlcykge1xuICAgICAgbGV0IGluc2VydGlvblBvaW50ID0gbGlzdE5vZGU7XG4gICAgICBjb25zdCBsaXN0SXRlbXMgPSAkZ2V0QWxsTGlzdEl0ZW1zKGxpc3ROb2RlKTtcbiAgICAgIGZvciAoY29uc3QgbGlzdEl0ZW1Ob2RlIG9mIGxpc3RJdGVtcykge1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLnNldFRleHRTdHlsZShzZWxlY3Rpb24uc3R5bGUpLnNldFRleHRGb3JtYXQoc2VsZWN0aW9uLmZvcm1hdCk7XG4gICAgICAgIGFwcGVuZChwYXJhZ3JhcGgsIGxpc3RJdGVtTm9kZS5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoKTtcbiAgICAgICAgaW5zZXJ0aW9uUG9pbnQgPSBwYXJhZ3JhcGg7XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgYW5jaG9yIGFuZCBmb2N1cyBmYWxsIG9uIHRoZSB0ZXh0Tm9kZVxuICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgdGhlIHRleHROb2RlIHdpbGwgYmUgYXBwZW5kZWQgdG9cbiAgICAgICAgLy8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG4gICAgICAgIC8vIFdoZW4gc2VsZWN0aW9uIGlzIGluIGVtcHR5IG5lc3RlZCBsaXN0IGl0ZW0sIHNlbGVjdGlvbiBpcyBhY3R1YWxseSBvbiB0aGUgbGlzdEl0ZW1Ob2RlLlxuICAgICAgICAvLyBXaGVuIHRoZSBjb3JyZXNwb25kaW5nIGxpc3RJdGVtTm9kZSBpcyBkZWxldGVkIGFuZCByZXBsYWNlZCBieSB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaFxuICAgICAgICAvLyB3ZSBzaG91bGQgbWFudWFsbHkgc2V0IHRoZSBzZWxlY3Rpb24ncyBmb2N1cyBhbmQgYW5jaG9yIHRvIHRoZSBuZXdseSBnZW5lcmF0ZWQgcGFyYWdyYXBoLlxuICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlLl9fa2V5ID09PSBzZWxlY3Rpb24uYW5jaG9yLmtleSkge1xuICAgICAgICAgICRzZXRQb2ludEZyb21DYXJldChzZWxlY3Rpb24uYW5jaG9yLCAkbm9ybWFsaXplQ2FyZXQoJGdldENoaWxkQ2FyZXQocGFyYWdyYXBoLCAnbmV4dCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICAgICAgICRzZXRQb2ludEZyb21DYXJldChzZWxlY3Rpb24uZm9jdXMsICRub3JtYWxpemVDYXJldCgkZ2V0Q2hpbGRDYXJldChwYXJhZ3JhcGgsICduZXh0JykpKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0SXRlbU5vZGUucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgdmFsdWUgb2YgYSBjaGlsZCBMaXN0SXRlbU5vZGUgYW5kIG1ha2VzIGl0IHRoZSB2YWx1ZSB0aGUgTGlzdEl0ZW1Ob2RlXG4gKiBzaG91bGQgYmUgaWYgaXQgaXNuJ3QgYWxyZWFkeS4gQWxzbyBlbnN1cmVzIHRoYXQgY2hlY2tlZCBpcyB1bmRlZmluZWQgaWYgdGhlXG4gKiBwYXJlbnQgZG9lcyBub3QgaGF2ZSBhIGxpc3QgdHlwZSBvZiAnY2hlY2snLlxuICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCB3aG9zZSBjaGlsZHJlbiBhcmUgdXBkYXRlZC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGxpc3QpIHtcbiAgY29uc3QgaXNOb3RDaGVja2xpc3QgPSBsaXN0LmdldExpc3RUeXBlKCkgIT09ICdjaGVjayc7XG4gIGxldCB2YWx1ZSA9IGxpc3QuZ2V0U3RhcnQoKTtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBsaXN0LmdldENoaWxkcmVuKCkpIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGNoaWxkKSkge1xuICAgICAgaWYgKGNoaWxkLmdldFZhbHVlKCkgIT09IHZhbHVlKSB7XG4gICAgICAgIGNoaWxkLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05vdENoZWNrbGlzdCAmJiBjaGlsZC5nZXRMYXRlc3QoKS5fX2NoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgICBjaGlsZC5zZXRDaGVja2VkKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICBpZiAoISRpc0xpc3ROb2RlKGNoaWxkLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICAgICAgdmFsdWUrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0aGUgbmV4dCBzaWJsaW5nIGxpc3QgaWYgc2FtZSB0eXBlLlxuICogPHVsPiB3aWxsIG1lcmdlIHdpdGggPHVsPiwgYnV0IE5PVCA8dWw+IHdpdGggPG9sPi5cbiAqIEBwYXJhbSBsaXN0IC0gVGhlIGxpc3Qgd2hvc2UgbmV4dCBzaWJsaW5nIHNob3VsZCBiZSBwb3RlbnRpYWxseSBtZXJnZWRcbiAqL1xuZnVuY3Rpb24gbWVyZ2VOZXh0U2libGluZ0xpc3RJZlNhbWVUeXBlKGxpc3QpIHtcbiAgY29uc3QgbmV4dFNpYmxpbmcgPSBsaXN0LmdldE5leHRTaWJsaW5nKCk7XG4gIGlmICgkaXNMaXN0Tm9kZShuZXh0U2libGluZykgJiYgbGlzdC5nZXRMaXN0VHlwZSgpID09PSBuZXh0U2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgbWVyZ2VMaXN0cyhsaXN0LCBuZXh0U2libGluZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGFuIGVtcHR5IExpc3ROb2RlL0xpc3RJdGVtTm9kZSBjaGFpbiBhdCBsaXN0SXRlbU5vZGUsIHNvIGFzIHRvXG4gKiBjcmVhdGUgYW4gaW5kZW50IGVmZmVjdC4gV29uJ3QgaW5kZW50IExpc3RJdGVtTm9kZXMgdGhhdCBoYXZlIGEgTGlzdE5vZGUgYXNcbiAqIGEgY2hpbGQsIGJ1dCBkb2VzIG1lcmdlIHNpYmxpbmcgTGlzdEl0ZW1Ob2RlcyBpZiBvbmUgaGFzIGEgbmVzdGVkIExpc3ROb2RlLlxuICogQHBhcmFtIGxpc3RJdGVtTm9kZSAtIFRoZSBMaXN0SXRlbU5vZGUgdG8gYmUgaW5kZW50ZWQuXG4gKi9cbmZ1bmN0aW9uICRoYW5kbGVJbmRlbnQobGlzdEl0ZW1Ob2RlKSB7XG4gIC8vIGdvIHRocm91Z2ggZWFjaCBub2RlIGFuZCBkZWNpZGUgd2hlcmUgdG8gbW92ZSBpdC5cbiAgY29uc3QgcmVtb3ZlZCA9IG5ldyBTZXQoKTtcbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSB8fCByZW1vdmVkLmhhcyhsaXN0SXRlbU5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IGxpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcblxuICAvLyBXZSBjYW4gY2FzdCBib3RoIG9mIHRoZSBiZWxvdyBgaXNOZXN0ZWRMaXN0Tm9kZWAgb25seSByZXR1cm5zIGEgYm9vbGVhbiB0eXBlIGluc3RlYWQgb2YgYSB1c2VyLWRlZmluZWQgdHlwZSBndWFyZHNcbiAgY29uc3QgbmV4dFNpYmxpbmcgPSBsaXN0SXRlbU5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbGlzdEl0ZW1Ob2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAvLyBpZiB0aGVyZSBhcmUgbmVzdGVkIGxpc3RzIG9uIGVpdGhlciBzaWRlLCBtZXJnZSB0aGVtIGFsbCB0b2dldGhlci5cblxuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykgJiYgaXNOZXN0ZWRMaXN0Tm9kZShwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgY29uc3QgaW5uZXJMaXN0ID0gcHJldmlvdXNTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgaW5uZXJMaXN0LmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuICAgICAgY29uc3QgbmV4dElubmVyTGlzdCA9IG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICgkaXNMaXN0Tm9kZShuZXh0SW5uZXJMaXN0KSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5leHRJbm5lckxpc3QuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgYXBwZW5kKGlubmVyTGlzdCwgY2hpbGRyZW4pO1xuICAgICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICAgICAgcmVtb3ZlZC5hZGQobmV4dFNpYmxpbmcuZ2V0S2V5KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgIC8vIGlmIHRoZSBMaXN0SXRlbU5vZGUgaXMgbmV4dCB0byBhIG5lc3RlZCBMaXN0Tm9kZSwgbWVyZ2UgdGhlbVxuICAgIGNvbnN0IGlubmVyTGlzdCA9IG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGlubmVyTGlzdC5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShsaXN0SXRlbU5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBpbm5lckxpc3QuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgbmVzdGVkIExpc3ROb2RlXG5cbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgY29uc3QgbmV3TGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCkuc2V0VGV4dEZvcm1hdChsaXN0SXRlbU5vZGUuZ2V0VGV4dEZvcm1hdCgpKS5zZXRUZXh0U3R5bGUobGlzdEl0ZW1Ob2RlLmdldFRleHRTdHlsZSgpKTtcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpLnNldFRleHRGb3JtYXQocGFyZW50LmdldFRleHRGb3JtYXQoKSkuc2V0VGV4dFN0eWxlKHBhcmVudC5nZXRUZXh0U3R5bGUoKSk7XG4gICAgICBuZXdMaXN0SXRlbS5hcHBlbmQobmV3TGlzdCk7XG4gICAgICBuZXdMaXN0LmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuICAgICAgaWYgKHByZXZpb3VzU2libGluZykge1xuICAgICAgICBwcmV2aW91c1NpYmxpbmcuaW5zZXJ0QWZ0ZXIobmV3TGlzdEl0ZW0pO1xuICAgICAgfSBlbHNlIGlmIChuZXh0U2libGluZykge1xuICAgICAgICBuZXh0U2libGluZy5pbnNlcnRCZWZvcmUobmV3TGlzdEl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZChuZXdMaXN0SXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpbmRlbnQgYnkgcmVtb3ZpbmcgYW4gZW1wdHkgTGlzdE5vZGUvTGlzdEl0ZW1Ob2RlIGNoYWluLiBBbiBpbmRlbnRlZCBMaXN0SXRlbU5vZGVcbiAqIGhhcyBhIGdyZWF0IGdyYW5kcGFyZW50IG5vZGUgb2YgdHlwZSBMaXN0Tm9kZSwgd2hpY2ggaXMgd2hlcmUgdGhlIExpc3RJdGVtTm9kZSB3aWxsIHJlc2lkZVxuICogd2l0aGluIGFzIGEgY2hpbGQuXG4gKiBAcGFyYW0gbGlzdEl0ZW1Ob2RlIC0gVGhlIExpc3RJdGVtTm9kZSB0byByZW1vdmUgdGhlIGluZGVudCAob3V0ZGVudCkuXG4gKi9cbmZ1bmN0aW9uICRoYW5kbGVPdXRkZW50KGxpc3RJdGVtTm9kZSkge1xuICAvLyBnbyB0aHJvdWdoIGVhY2ggbm9kZSBhbmQgZGVjaWRlIHdoZXJlIHRvIG1vdmUgaXQuXG5cbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJlbnRMaXN0ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuICBjb25zdCBncmFuZHBhcmVudExpc3RJdGVtID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0UGFyZW50KCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGdyZWF0R3JhbmRwYXJlbnRMaXN0ID0gZ3JhbmRwYXJlbnRMaXN0SXRlbSA/IGdyYW5kcGFyZW50TGlzdEl0ZW0uZ2V0UGFyZW50KCkgOiB1bmRlZmluZWQ7XG4gIC8vIElmIGl0IGRvZXNuJ3QgaGF2ZSB0aGVzZSBhbmNlc3RvcnMsIGl0J3Mgbm90IGluZGVudGVkLlxuXG4gIGlmICgkaXNMaXN0Tm9kZShncmVhdEdyYW5kcGFyZW50TGlzdCkgJiYgJGlzTGlzdEl0ZW1Ob2RlKGdyYW5kcGFyZW50TGlzdEl0ZW0pICYmICRpc0xpc3ROb2RlKHBhcmVudExpc3QpKSB7XG4gICAgLy8gaWYgaXQncyB0aGUgZmlyc3QgY2hpbGQgaW4gaXQncyBwYXJlbnQgbGlzdCwgaW5zZXJ0IGl0IGludG8gdGhlXG4gICAgLy8gZ3JlYXQgZ3JhbmRwYXJlbnQgbGlzdCBiZWZvcmUgdGhlIGdyYW5kcGFyZW50XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldEZpcnN0Q2hpbGQoKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRMYXN0Q2hpbGQoKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAobGlzdEl0ZW1Ob2RlLmlzKGZpcnN0Q2hpbGQpKSB7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEJlZm9yZShsaXN0SXRlbU5vZGUpO1xuICAgICAgaWYgKHBhcmVudExpc3QuaXNFbXB0eSgpKSB7XG4gICAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0ucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICAvLyBpZiBpdCdzIHRoZSBsYXN0IGNoaWxkIGluIGl0J3MgcGFyZW50IGxpc3QsIGluc2VydCBpdCBpbnRvIHRoZVxuICAgICAgLy8gZ3JlYXQgZ3JhbmRwYXJlbnQgbGlzdCBhZnRlciB0aGUgZ3JhbmRwYXJlbnQuXG4gICAgfSBlbHNlIGlmIChsaXN0SXRlbU5vZGUuaXMobGFzdENoaWxkKSkge1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRBZnRlcihsaXN0SXRlbU5vZGUpO1xuICAgICAgaWYgKHBhcmVudExpc3QuaXNFbXB0eSgpKSB7XG4gICAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0ucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSwgd2UgbmVlZCB0byBzcGxpdCB0aGUgc2libGluZ3MgaW50byB0d28gbmV3IG5lc3RlZCBsaXN0c1xuICAgICAgY29uc3QgbGlzdFR5cGUgPSBwYXJlbnRMaXN0LmdldExpc3RUeXBlKCk7XG4gICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmdzTGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmdzTGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICBwcmV2aW91c1NpYmxpbmdzTGlzdEl0ZW0uYXBwZW5kKHByZXZpb3VzU2libGluZ3NMaXN0KTtcbiAgICAgIGxpc3RJdGVtTm9kZS5nZXRQcmV2aW91c1NpYmxpbmdzKCkuZm9yRWFjaChzaWJsaW5nID0+IHByZXZpb3VzU2libGluZ3NMaXN0LmFwcGVuZChzaWJsaW5nKSk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3NMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgbmV4dFNpYmxpbmdzTGlzdEl0ZW0uYXBwZW5kKG5leHRTaWJsaW5nc0xpc3QpO1xuICAgICAgYXBwZW5kKG5leHRTaWJsaW5nc0xpc3QsIGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZ3MoKSk7XG4gICAgICAvLyBwdXQgdGhlIHNpYmxpbmcgbmVzdGVkIGxpc3RzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBncmFuZHBhcmVudCBsaXN0IGl0ZW0gaW4gdGhlIGdyZWF0IGdyYW5kcGFyZW50LlxuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRCZWZvcmUocHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtKTtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QWZ0ZXIobmV4dFNpYmxpbmdzTGlzdEl0ZW0pO1xuICAgICAgLy8gcmVwbGFjZSB0aGUgZ3JhbmRwYXJlbnQgbGlzdCBpdGVtIChub3cgYmV0d2VlbiB0aGUgc2libGluZ3MpIHdpdGggdGhlIG91dGRlbnRlZCBsaXN0IGl0ZW0uXG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlcGxhY2UobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgYSBQYXJhZ3JhcGhOb2RlIGF0IHNlbGVjdGlvbiBhbmQgc2VsZWN0cyB0aGUgbmV3IG5vZGUuIFRoZSBzZWxlY3Rpb24gbXVzdCBjb250YWluIGEgTGlzdEl0ZW1Ob2RlXG4gKiBvciBhIG5vZGUgdGhhdCBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gdGV4dC4gSWYgaXRzIGdyYW5kcGFyZW50IGlzIHRoZSByb290L3NoYWRvdyByb290LCBpdCB3aWxsIGdldCB0aGUgTGlzdE5vZGVcbiAqICh3aGljaCBzaG91bGQgYmUgdGhlIHBhcmVudCBub2RlKSBhbmQgaW5zZXJ0IHRoZSBQYXJhZ3JhcGhOb2RlIGFzIGEgc2libGluZyB0byB0aGUgTGlzdE5vZGUuIElmIHRoZSBMaXN0Tm9kZSBpc1xuICogbmVzdGVkIGluIGEgTGlzdEl0ZW1Ob2RlIGluc3RlYWQsIGl0IHdpbGwgYWRkIHRoZSBQYXJhZ3JhcGhOb2RlIGFmdGVyIHRoZSBncmFuZHBhcmVudCBMaXN0SXRlbU5vZGUuXG4gKiBUaHJvd3MgYW4gaW52YXJpYW50IGlmIHRoZSBzZWxlY3Rpb24gaXMgbm90IGEgY2hpbGQgb2YgYSBMaXN0Tm9kZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgYSBQYXJhZ3JhcGhOb2RlIHdhcyBpbnNlcnRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvblxuICogb3IgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBjb250YWluIGEgTGlzdEl0ZW1Ob2RlIG9yIHRoZSBub2RlIGFscmVhZHkgaG9sZHMgdGV4dC5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPbmx5IHJ1biB0aGlzIGNvZGUgb24gZW1wdHkgbGlzdCBpdGVtc1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCEkaXNMaXN0SXRlbU5vZGUoYW5jaG9yKSB8fCBhbmNob3IuZ2V0Q2hpbGRyZW5TaXplKCkgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdG9wTGlzdE5vZGUgPSAkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yKTtcbiAgY29uc3QgcGFyZW50ID0gYW5jaG9yLmdldFBhcmVudCgpO1xuICBpZiAoISRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEEgTGlzdEl0ZW1Ob2RlIG11c3QgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5gKTtcbiAgfVxuICBjb25zdCBncmFuZHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgbGV0IHJlcGxhY2VtZW50Tm9kZTtcbiAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoZ3JhbmRwYXJlbnQpKSB7XG4gICAgcmVwbGFjZW1lbnROb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICB0b3BMaXN0Tm9kZS5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudCkpIHtcbiAgICByZXBsYWNlbWVudE5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgZ3JhbmRwYXJlbnQuaW5zZXJ0QWZ0ZXIocmVwbGFjZW1lbnROb2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVwbGFjZW1lbnROb2RlLnNldFRleHRTdHlsZShzZWxlY3Rpb24uc3R5bGUpLnNldFRleHRGb3JtYXQoc2VsZWN0aW9uLmZvcm1hdCkuc2VsZWN0KCk7XG4gIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvci5nZXROZXh0U2libGluZ3MoKTtcbiAgaWYgKG5leHRTaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShwYXJlbnQuZ2V0TGlzdFR5cGUoKSk7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShyZXBsYWNlbWVudE5vZGUpKSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZChuZXdMaXN0KTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0KTtcbiAgICB9XG4gICAgbmV3TGlzdC5hcHBlbmQoLi4ubmV4dFNpYmxpbmdzKTtcbiAgfVxuXG4gIC8vIERvbid0IGxlYXZlIGhhbmdpbmcgbmVzdGVkIGVtcHR5IGxpc3RzXG4gICRyZW1vdmVIaWdoZXN0RW1wdHlMaXN0UGFyZW50KGFuY2hvcik7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcykge1xuICBjb25zdCBydmFsID0gW107XG4gIGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICBpZiAoY2xhc3NOYW1lICYmIHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3IgKGNvbnN0IFtzXSBvZiBjbGFzc05hbWUubWF0Y2hBbGwoL1xcUysvZykpIHtcbiAgICAgICAgcnZhbC5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuZnVuY3Rpb24gYXBwbHlNYXJrZXJTdHlsZXMoZG9tLCBub2RlLCBwcmV2Tm9kZSkge1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21DU1Mobm9kZS5fX3RleHRTdHlsZSk7XG4gIGZvciAoY29uc3QgayBpbiBzdHlsZXMpIHtcbiAgICBkb20uc3R5bGUuc2V0UHJvcGVydHkoYC0tbGlzdGl0ZW0tbWFya2VyLSR7a31gLCBzdHlsZXNba10pO1xuICB9XG4gIGlmIChwcmV2Tm9kZSkge1xuICAgIGZvciAoY29uc3QgayBpbiBnZXRTdHlsZU9iamVjdEZyb21DU1MocHJldk5vZGUuX190ZXh0U3R5bGUpKSB7XG4gICAgICBpZiAoIShrIGluIHN0eWxlcykpIHtcbiAgICAgICAgZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KGAtLWxpc3RpdGVtLW1hcmtlci0ke2t9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaXN0SXRlbU5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICAkY29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZygnbGlzdGl0ZW0nLCB7XG4gICAgICAkdHJhbnNmb3JtOiBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUuX19jaGVja2VkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICBpZiAocGFyZW50LmdldExpc3RUeXBlKCkgIT09ICdjaGVjaycgJiYgbm9kZS5nZXRDaGVja2VkKCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5zZXRDaGVja2VkKHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXh0ZW5kczogRWxlbWVudE5vZGUsXG4gICAgICBpbXBvcnRET006IGJ1aWxkSW1wb3J0TWFwKHtcbiAgICAgICAgbGk6ICgpID0+ICh7XG4gICAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaXN0SXRlbUVsZW1lbnQsXG4gICAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3RydWN0b3IodmFsdWUgPSAxLCBjaGVja2VkID0gdW5kZWZpbmVkLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX192YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyAxIDogdmFsdWU7XG4gICAgdGhpcy5fX2NoZWNrZWQgPSBjaGVja2VkO1xuICB9XG4gIGFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKSB7XG4gICAgc3VwZXIuYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpO1xuICAgIHRoaXMuX192YWx1ZSA9IHByZXZOb2RlLl9fdmFsdWU7XG4gICAgdGhpcy5fX2NoZWNrZWQgPSBwcmV2Tm9kZS5fX2NoZWNrZWQ7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIHRoaXMudXBkYXRlTGlzdEl0ZW1ET00obnVsbCwgZWxlbWVudCwgY29uZmlnKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVMaXN0SXRlbURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snKSB7XG4gICAgICB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCB0aGlzLCBwcmV2Tm9kZSk7XG4gICAgfVxuICAgIGRvbS52YWx1ZSA9IHRoaXMuX192YWx1ZTtcbiAgICAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIGNvbnN0IHByZXZTdHlsZSA9IHByZXZOb2RlID8gcHJldk5vZGUuX19zdHlsZSA6ICcnO1xuICAgIGNvbnN0IG5leHRTdHlsZSA9IHRoaXMuX19zdHlsZTtcbiAgICBpZiAocHJldlN0eWxlICE9PSBuZXh0U3R5bGUpIHtcbiAgICAgIGlmIChuZXh0U3R5bGUgPT09ICcnKSB7XG4gICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG5leHRTdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlNYXJrZXJTdHlsZXMoZG9tLCB0aGlzLCBwcmV2Tm9kZSk7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGFsd2F5cyBIVE1MTGlzdEl0ZW1FbGVtZW50XG4gICAgY29uc3QgZWxlbWVudCA9IGRvbTtcbiAgICB0aGlzLnVwZGF0ZUxpc3RJdGVtRE9NKHByZXZOb2RlLCBlbGVtZW50LCBjb25maWcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0VmFsdWUoc2VyaWFsaXplZE5vZGUudmFsdWUpLnNldENoZWNrZWQoc2VyaWFsaXplZE5vZGUuY2hlY2tlZCk7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZURPTShlZGl0b3IuX2NvbmZpZyk7XG4gICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgIGlmIChmb3JtYXRUeXBlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9IGZvcm1hdFR5cGU7XG4gICAgfVxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBjaGVja2VkOiB0aGlzLmdldENoZWNrZWQoKSxcbiAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKClcbiAgICB9O1xuICB9XG4gIGFwcGVuZCguLi5ub2Rlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiB0aGlzLmNhbk1lcmdlV2l0aChub2RlKSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXBsYWNlKHJlcGxhY2VXaXRoTm9kZSwgaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShyZXBsYWNlV2l0aE5vZGUpKSB7XG4gICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnNldEluZGVudCgwKTtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VXaXRoTm9kZTtcbiAgICB9XG4gICAgaWYgKGxpc3QuX19maXJzdCA9PT0gdGhpcy5nZXRLZXkoKSkge1xuICAgICAgbGlzdC5pbnNlcnRCZWZvcmUocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3QuX19sYXN0ID09PSB0aGlzLmdldEtleSgpKSB7XG4gICAgICBsaXN0Lmluc2VydEFmdGVyKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNwbGl0IHRoZSBsaXN0XG4gICAgICBjb25zdCBuZXdMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3QuZ2V0TGlzdFR5cGUoKSk7XG4gICAgICBsZXQgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICB3aGlsZSAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgY29uc3Qgbm9kZVRvQXBwZW5kID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgbmV3TGlzdC5hcHBlbmQobm9kZVRvQXBwZW5kKTtcbiAgICAgIH1cbiAgICAgIGxpc3QuaW5zZXJ0QWZ0ZXIocmVwbGFjZVdpdGhOb2RlKTtcbiAgICAgIHJlcGxhY2VXaXRoTm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0KTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShyZXBsYWNlV2l0aE5vZGUpKSB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5jbHVkZUNoaWxkcmVuIHNob3VsZCBvbmx5IGJlIHRydWUgZm9yIEVsZW1lbnROb2Rlc2ApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICByZXBsYWNlV2l0aE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIGlmIChsaXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBsaXN0LnJlbW92ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZVdpdGhOb2RlO1xuICB9XG4gIGluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbGlzdE5vZGUgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluc2VydEFmdGVyOiBsaXN0IG5vZGUgaXMgbm90IHBhcmVudCBvZiBsaXN0IGl0ZW0gbm9kZWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5nZXROZXh0U2libGluZ3MoKTtcblxuICAgIC8vIFNwbGl0IHRoZSBsaXN0cyBhbmQgaW5zZXJ0IHRoZSBub2RlIGluIGJldHdlZW4gdGhlbVxuICAgIGxpc3ROb2RlLmluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIGlmIChzaWJsaW5ncy5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IG5ld0xpc3ROb2RlID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3ROb2RlLmdldExpc3RUeXBlKCkpO1xuICAgICAgc2libGluZ3MuZm9yRWFjaChzaWJsaW5nID0+IG5ld0xpc3ROb2RlLmFwcGVuZChzaWJsaW5nKSk7XG4gICAgICBub2RlLmluc2VydEFmdGVyKG5ld0xpc3ROb2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmVtb3ZlKHByZXNlcnZlRW1wdHlQYXJlbnQpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgc3VwZXIucmVtb3ZlKHByZXNlcnZlRW1wdHlQYXJlbnQpO1xuICAgIGlmIChwcmV2U2libGluZyAmJiBuZXh0U2libGluZyAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgbWVyZ2VMaXN0cyhwcmV2U2libGluZy5nZXRGaXJzdENoaWxkKCksIG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0TmV3QWZ0ZXIoXywgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpLnVwZGF0ZUZyb21KU09OKHRoaXMuZXhwb3J0SlNPTigpKS5zZXRDaGVja2VkKHRoaXMuZ2V0Q2hlY2tlZCgpID8gZmFsc2UgOiB1bmRlZmluZWQpO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KHNlbGVjdGlvbikge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgY29uc3QgbGlzdE5vZGUgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBsaXN0Tm9kZVBhcmVudCA9IGxpc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBpc0luZGVudGVkID0gJGlzTGlzdEl0ZW1Ob2RlKGxpc3ROb2RlUGFyZW50KTtcbiAgICBpZiAobGlzdE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEpIHtcbiAgICAgIGlmIChpc0luZGVudGVkKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsaXN0IG5vZGUgaXMgbmVzdGVkLCB3ZSBqdXN0IHdhbnQgdG8gcmVtb3ZlIGl0LFxuICAgICAgICAvLyBlZmZlY3RpdmVseSB1bmluZGVudGluZyBpdC5cbiAgICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIGxpc3ROb2RlUGFyZW50LnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdE5vZGUuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaCk7XG4gICAgICAgIGxpc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHNlbGVjdGlvbiBvbiB0aGUgbGlzdCBpdGVtLCB3ZSdsbCBuZWVkIHRvIG1vdmUgaXRcbiAgICAgICAgLy8gdG8gdGhlIHBhcmFncmFwaFxuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyYWdyYXBoLmdldEtleSgpO1xuICAgICAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3IuZ2V0Tm9kZSgpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgYW5jaG9yLnNldChrZXksIGFuY2hvci5vZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiBmb2N1cy5nZXROb2RlKCkuaXModGhpcykpIHtcbiAgICAgICAgICBmb2N1cy5zZXQoa2V5LCBmb2N1cy5vZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdE5vZGUuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaCk7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRWYWx1ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3ZhbHVlO1xuICB9XG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRDaGVja2VkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGxldCBsaXN0VHlwZTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBsaXN0VHlwZSA9IHBhcmVudC5nZXRMaXN0VHlwZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdFR5cGUgPT09ICdjaGVjaycgPyBCb29sZWFuKHNlbGYuX19jaGVja2VkKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19jaGVja2VkID0gY2hlY2tlZDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICB0b2dnbGVDaGVja2VkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHNlbGYuc2V0Q2hlY2tlZCghc2VsZi5fX2NoZWNrZWQpO1xuICB9XG4gIGdldEluZGVudCgpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcGFyZW50LCB3ZSBhcmUgbGlrZWx5IHNlcmlhbGl6aW5nXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09PSBudWxsIHx8ICF0aGlzLmlzQXR0YWNoZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19pbmRlbnQ7XG4gICAgfVxuICAgIC8vIExpc3RJdGVtTm9kZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuXG4gICAgbGV0IGxpc3ROb2RlUGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBsZXQgaW5kZW50TGV2ZWwgPSAwO1xuICAgIHdoaWxlICgkaXNMaXN0SXRlbU5vZGUobGlzdE5vZGVQYXJlbnQpKSB7XG4gICAgICBsaXN0Tm9kZVBhcmVudCA9IGxpc3ROb2RlUGFyZW50LmdldFBhcmVudE9yVGhyb3coKS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBpbmRlbnRMZXZlbCsrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZW50TGV2ZWw7XG4gIH1cbiAgc2V0SW5kZW50KGluZGVudCkge1xuICAgIGlmICghKHR5cGVvZiBpbmRlbnQgPT09ICdudW1iZXInKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBJbnZhbGlkIGluZGVudCB2YWx1ZS5gKTtcbiAgICB9XG4gICAgaW5kZW50ID0gTWF0aC5mbG9vcihpbmRlbnQpO1xuICAgIGlmICghKGluZGVudCA+PSAwKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBJbmRlbnQgdmFsdWUgbXVzdCBiZSBub24tbmVnYXRpdmUuYCk7XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5kZW50ID0gdGhpcy5nZXRJbmRlbnQoKTtcbiAgICB3aGlsZSAoY3VycmVudEluZGVudCAhPT0gaW5kZW50KSB7XG4gICAgICBpZiAoY3VycmVudEluZGVudCA8IGluZGVudCkge1xuICAgICAgICAkaGFuZGxlSW5kZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50SW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaGFuZGxlT3V0ZGVudCh0aGlzKTtcbiAgICAgICAgY3VycmVudEluZGVudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgKi9cbiAgY2FuSW5zZXJ0QWZ0ZXIobm9kZSkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUobm9kZSk7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhblJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShyZXBsYWNlbWVudCk7XG4gIH1cbiAgY2FuTWVyZ2VXaXRoKG5vZGUpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpIHx8ICRpc1BhcmFncmFwaE5vZGUobm9kZSk7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA9PT0gc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCkubGVuZ3RoO1xuICB9XG4gIGlzUGFyZW50UmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKSB7XG4gICAgcmV0dXJuICRjcmVhdGVMaXN0Tm9kZSgnYnVsbGV0Jyk7XG4gIH1cbiAgY2FuTWVyZ2VXaGVuRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhkb20sIGVkaXRvclRoZW1lQ2xhc3Nlcywgbm9kZSkge1xuICBjb25zdCBjbGFzc2VzVG9BZGQgPSBbXTtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gW107XG4gIGNvbnN0IGxpc3RUaGVtZSA9IGVkaXRvclRoZW1lQ2xhc3Nlcy5saXN0O1xuICBjb25zdCBsaXN0SXRlbUNsYXNzTmFtZSA9IGxpc3RUaGVtZSA/IGxpc3RUaGVtZS5saXN0aXRlbSA6IHVuZGVmaW5lZDtcbiAgbGV0IG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lO1xuICBpZiAobGlzdFRoZW1lICYmIGxpc3RUaGVtZS5uZXN0ZWQpIHtcbiAgICBuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZSA9IGxpc3RUaGVtZS5uZXN0ZWQubGlzdGl0ZW07XG4gIH1cbiAgaWYgKGxpc3RJdGVtQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5ub3JtYWxpemVDbGFzc05hbWVzKGxpc3RJdGVtQ2xhc3NOYW1lKSk7XG4gIH1cbiAgaWYgKGxpc3RUaGVtZSkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGNvbnN0IGlzQ2hlY2tMaXN0ID0gJGlzTGlzdE5vZGUocGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZS5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snO1xuICAgIGNvbnN0IGNoZWNrZWQgPSBub2RlLmdldENoZWNrZWQoKTtcbiAgICBpZiAoIWlzQ2hlY2tMaXN0IHx8IGNoZWNrZWQpIHtcbiAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKGxpc3RUaGVtZS5saXN0aXRlbVVuY2hlY2tlZCk7XG4gICAgfVxuICAgIGlmICghaXNDaGVja0xpc3QgfHwgIWNoZWNrZWQpIHtcbiAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKGxpc3RUaGVtZS5saXN0aXRlbUNoZWNrZWQpO1xuICAgIH1cbiAgICBpZiAoaXNDaGVja0xpc3QpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGNoZWNrZWQgPyBsaXN0VGhlbWUubGlzdGl0ZW1DaGVja2VkIDogbGlzdFRoZW1lLmxpc3RpdGVtVW5jaGVja2VkKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBuZXN0ZWRMaXN0SXRlbUNsYXNzZXMgPSBub3JtYWxpemVDbGFzc05hbWVzKG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lKTtcbiAgICBpZiAobm9kZS5nZXRDaGlsZHJlbigpLnNvbWUoY2hpbGQgPT4gJGlzTGlzdE5vZGUoY2hpbGQpKSkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgfVxuICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvQWRkKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlTGlzdEl0ZW1DaGVja2VkKGRvbSwgbGlzdEl0ZW1Ob2RlLCBwcmV2TGlzdEl0ZW1Ob2RlLCBsaXN0Tm9kZSkge1xuICAvLyBPbmx5IGFkZCBhdHRyaWJ1dGVzIGZvciBsZWFmIGxpc3QgaXRlbXNcbiAgaWYgKCRpc0xpc3ROb2RlKGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCkpKSB7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJyk7XG4gIH0gZWxzZSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgncm9sZScsICdjaGVja2JveCcpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgJy0xJyk7XG4gICAgaWYgKCFwcmV2TGlzdEl0ZW1Ob2RlIHx8IGxpc3RJdGVtTm9kZS5fX2NoZWNrZWQgIT09IHByZXZMaXN0SXRlbU5vZGUuX19jaGVja2VkKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCBsaXN0SXRlbU5vZGUuZ2V0Q2hlY2tlZCgpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkY29udmVydExpc3RJdGVtRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGlzR2l0SHViQ2hlY2tMaXN0ID0gZG9tTm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3Rhc2stbGlzdC1pdGVtJyk7XG4gIGlmIChpc0dpdEh1YkNoZWNrTGlzdCkge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZG9tTm9kZS5jaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgcmV0dXJuICRjb252ZXJ0Q2hlY2tib3hJbnB1dChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGFyaWFDaGVja2VkQXR0ciA9IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKTtcbiAgY29uc3QgY2hlY2tlZCA9IGFyaWFDaGVja2VkQXR0ciA9PT0gJ3RydWUnID8gdHJ1ZSA6IGFyaWFDaGVja2VkQXR0ciA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVMaXN0SXRlbU5vZGUoY2hlY2tlZClcbiAgfTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0Q2hlY2tib3hJbnB1dChkb21Ob2RlKSB7XG4gIGNvbnN0IGlzQ2hlY2tib3hJbnB1dCA9IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdjaGVja2JveCc7XG4gIGlmICghaXNDaGVja2JveElucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNoZWNrZWQgPSBkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVMaXN0SXRlbU5vZGUoY2hlY2tlZClcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExpc3QgSXRlbSBub2RlLCBwYXNzaW5nIHRydWUvZmFsc2Ugd2lsbCBjb252ZXJ0IGl0IHRvIGEgY2hlY2tib3ggaW5wdXQuXG4gKiBAcGFyYW0gY2hlY2tlZCAtIElzIHRoZSBMaXN0IEl0ZW0gYSBjaGVja2JveCBhbmQsIGlmIHNvLCBpcyBpdCBjaGVja2VkPyB1bmRlZmluZWQvbnVsbDogbm90IGEgY2hlY2tib3gsIHRydWUvZmFsc2UgaXMgYSBjaGVja2JveCBhbmQgY2hlY2tlZC91bmNoZWNrZWQsIHJlc3BlY3RpdmVseS5cbiAqIEByZXR1cm5zIFRoZSBuZXcgTGlzdCBJdGVtLlxuICovXG5mdW5jdGlvbiAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGNoZWNrZWQpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlzdEl0ZW1Ob2RlKHVuZGVmaW5lZCwgY2hlY2tlZCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0xpc3RJdGVtTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTGlzdEl0ZW1Ob2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaXN0Tm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICAkY29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZygnbGlzdCcsIHtcbiAgICAgICR0cmFuc2Zvcm06IG5vZGUgPT4ge1xuICAgICAgICBtZXJnZU5leHRTaWJsaW5nTGlzdElmU2FtZVR5cGUobm9kZSk7XG4gICAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShub2RlKTtcbiAgICAgIH0sXG4gICAgICBleHRlbmRzOiBFbGVtZW50Tm9kZSxcbiAgICAgIGltcG9ydERPTTogYnVpbGRJbXBvcnRNYXAoe1xuICAgICAgICBvbDogKCkgPT4gKHtcbiAgICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydExpc3ROb2RlLFxuICAgICAgICAgIHByaW9yaXR5OiAwXG4gICAgICAgIH0pLFxuICAgICAgICB1bDogKCkgPT4gKHtcbiAgICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydExpc3ROb2RlLFxuICAgICAgICAgIHByaW9yaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKGxpc3RUeXBlID0gJ251bWJlcicsIHN0YXJ0ID0gMSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCBfbGlzdFR5cGUgPSBUQUdfVE9fTElTVF9UWVBFW2xpc3RUeXBlXSB8fCBsaXN0VHlwZTtcbiAgICB0aGlzLl9fbGlzdFR5cGUgPSBfbGlzdFR5cGU7XG4gICAgdGhpcy5fX3RhZyA9IF9saXN0VHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgICB0aGlzLl9fc3RhcnQgPSBzdGFydDtcbiAgfVxuICBhZnRlckNsb25lRnJvbShwcmV2Tm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKTtcbiAgICB0aGlzLl9fbGlzdFR5cGUgPSBwcmV2Tm9kZS5fX2xpc3RUeXBlO1xuICAgIHRoaXMuX190YWcgPSBwcmV2Tm9kZS5fX3RhZztcbiAgICB0aGlzLl9fc3RhcnQgPSBwcmV2Tm9kZS5fX3N0YXJ0O1xuICB9XG4gIGdldFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3RhZztcbiAgfVxuICBzZXRMaXN0VHlwZSh0eXBlKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19saXN0VHlwZSA9IHR5cGU7XG4gICAgd3JpdGFibGUuX190YWcgPSB0eXBlID09PSAnbnVtYmVyJyA/ICdvbCcgOiAndWwnO1xuICAgIHJldHVybiB3cml0YWJsZTtcbiAgfVxuICBnZXRMaXN0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2xpc3RUeXBlO1xuICB9XG4gIGdldFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fc3RhcnQ7XG4gIH1cbiAgc2V0U3RhcnQoc3RhcnQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19zdGFydCA9IHN0YXJ0O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcsIF9lZGl0b3IpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLl9fdGFnO1xuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGhpcy5fX3N0YXJ0ICE9PSAxKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKCdzdGFydCcsIFN0cmluZyh0aGlzLl9fc3RhcnQpKTtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBJbnRlcm5hbCBmaWVsZC5cbiAgICBkb20uX19sZXhpY2FsTGlzdFR5cGUgPSB0aGlzLl9fbGlzdFR5cGU7XG4gICAgJHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBkb207XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGlmIChwcmV2Tm9kZS5fX3RhZyAhPT0gdGhpcy5fX3RhZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICRzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldExpc3RUeXBlKHNlcmlhbGl6ZWROb2RlLmxpc3RUeXBlKS5zZXRTdGFydChzZXJpYWxpemVkTm9kZS5zdGFydCk7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZURPTShlZGl0b3IuX2NvbmZpZywgZWRpdG9yKTtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuX19zdGFydCAhPT0gMSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3RhcnQnLCBTdHJpbmcodGhpcy5fX3N0YXJ0KSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX2xpc3RUeXBlID09PSAnY2hlY2snKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdfX2xleGljYWxMaXN0VHlwZScsICdjaGVjaycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgbGlzdFR5cGU6IHRoaXMuZ2V0TGlzdFR5cGUoKSxcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFN0YXJ0KCksXG4gICAgICB0YWc6IHRoaXMuZ2V0VGFnKClcbiAgICB9O1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgbm9kZXNUb0luc2VydCkge1xuICAgIGxldCBsaXN0SXRlbU5vZGVzVG9JbnNlcnQgPSBub2Rlc1RvSW5zZXJ0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb0luc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzVG9JbnNlcnRbaV07XG4gICAgICBpZiAoISRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgICBpZiAobGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0ID09PSBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgICAgICAgbGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0ID0gWy4uLm5vZGVzVG9JbnNlcnRdO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RJdGVtTm9kZXNUb0luc2VydFtpXSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKS5hcHBlbmQoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgISgkaXNMaXN0Tm9kZShub2RlKSB8fCBub2RlLmlzSW5saW5lKCkpID8gJGNyZWF0ZVRleHROb2RlKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSkgOiBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIGxpc3RJdGVtTm9kZXNUb0luc2VydCk7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoY2hpbGQpO1xuICB9XG59XG5mdW5jdGlvbiAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGVkaXRvclRoZW1lQ2xhc3Nlcywgbm9kZSkge1xuICBjb25zdCBjbGFzc2VzVG9BZGQgPSBbXTtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gW107XG4gIGNvbnN0IGxpc3RUaGVtZSA9IGVkaXRvclRoZW1lQ2xhc3Nlcy5saXN0O1xuICBpZiAobGlzdFRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsaXN0TGV2ZWxzQ2xhc3NOYW1lcyA9IGxpc3RUaGVtZVtgJHtub2RlLl9fdGFnfURlcHRoYF0gfHwgW107XG4gICAgY29uc3QgbGlzdERlcHRoID0gJGdldExpc3REZXB0aChub2RlKSAtIDE7XG4gICAgY29uc3Qgbm9ybWFsaXplZExpc3REZXB0aCA9IGxpc3REZXB0aCAlIGxpc3RMZXZlbHNDbGFzc05hbWVzLmxlbmd0aDtcbiAgICBjb25zdCBsaXN0TGV2ZWxDbGFzc05hbWUgPSBsaXN0TGV2ZWxzQ2xhc3NOYW1lc1tub3JtYWxpemVkTGlzdERlcHRoXTtcbiAgICBjb25zdCBsaXN0Q2xhc3NOYW1lID0gbGlzdFRoZW1lW25vZGUuX190YWddO1xuICAgIGxldCBuZXN0ZWRMaXN0Q2xhc3NOYW1lO1xuICAgIGNvbnN0IG5lc3RlZExpc3RUaGVtZSA9IGxpc3RUaGVtZS5uZXN0ZWQ7XG4gICAgY29uc3QgY2hlY2tsaXN0Q2xhc3NOYW1lID0gbGlzdFRoZW1lLmNoZWNrbGlzdDtcbiAgICBpZiAobmVzdGVkTGlzdFRoZW1lICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkTGlzdFRoZW1lLmxpc3QpIHtcbiAgICAgIG5lc3RlZExpc3RDbGFzc05hbWUgPSBuZXN0ZWRMaXN0VGhlbWUubGlzdDtcbiAgICB9XG4gICAgaWYgKGxpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2gobGlzdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChjaGVja2xpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCAmJiBub2RlLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGNoZWNrbGlzdENsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChsaXN0TGV2ZWxDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubm9ybWFsaXplQ2xhc3NOYW1lcyhsaXN0TGV2ZWxDbGFzc05hbWUpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExldmVsc0NsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT09IG5vcm1hbGl6ZWRMaXN0RGVwdGgpIHtcbiAgICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChub2RlLl9fdGFnICsgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lc3RlZExpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1DbGFzc2VzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhuZXN0ZWRMaXN0Q2xhc3NOYW1lKTtcbiAgICAgIGlmIChsaXN0RGVwdGggPiAxKSB7XG4gICAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIG5vcm1hbGl6ZXMgdGhlIGNoaWxkcmVuIG9mIGEgTGlzdE5vZGUgYWZ0ZXIgdGhlIGNvbnZlcnNpb24gZnJvbSBIVE1MLFxuICogZW5zdXJpbmcgdGhhdCB0aGV5IGFyZSBhbGwgTGlzdEl0ZW1Ob2RlcyBhbmQgY29udGFpbiBlaXRoZXIgYSBzaW5nbGUgbmVzdGVkIExpc3ROb2RlXG4gKiBvciBzb21lIG90aGVyIGlubGluZSBjb250ZW50LlxuICovXG5mdW5jdGlvbiAkbm9ybWFsaXplQ2hpbGRyZW4obm9kZXMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZExpc3RJdGVtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaChub2RlKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKCR3cmFwSW5MaXN0SXRlbShjaGlsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaCgkd3JhcEluTGlzdEl0ZW0obm9kZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZExpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGlzRG9tQ2hlY2tsaXN0KGRvbU5vZGUpIHtcbiAgaWYgKGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdfX2xleGljYWxsaXN0dHlwZScpID09PSAnY2hlY2snIHx8XG4gIC8vIGlzIGdpdGh1YiBjaGVja2xpc3RcbiAgZG9tTm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbnRhaW5zLXRhc2stbGlzdCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gaWYgY2hpbGRyZW4gYXJlIGNoZWNrbGlzdCBpdGVtcywgdGhlIG5vZGUgaXMgYSBjaGVja2xpc3QgdWwuIEFwcGxpY2FibGUgZm9yIGdvb2dsZWRvYyBjaGVja2xpc3QgcGFzdGluZy5cbiAgZm9yIChjb25zdCBjaGlsZCBvZiBkb21Ob2RlLmNoaWxkTm9kZXMpIHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuaGFzQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGlzdE5vZGUoZG9tTm9kZSkge1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBpZiAobm9kZU5hbWUgPT09ICdvbCcpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3RhcnQgPSBkb21Ob2RlLnN0YXJ0O1xuICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ251bWJlcicsIHN0YXJ0KTtcbiAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ3VsJykge1xuICAgIGlmIChpc0RvbUNoZWNrbGlzdChkb21Ob2RlKSkge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnY2hlY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnYnVsbGV0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6ICRub3JtYWxpemVDaGlsZHJlbixcbiAgICBub2RlXG4gIH07XG59XG5jb25zdCBUQUdfVE9fTElTVF9UWVBFID0ge1xuICBvbDogJ251bWJlcicsXG4gIHVsOiAnYnVsbGV0J1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgTGlzdE5vZGUgb2YgbGlzdFR5cGUuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0IHRvIGJlIGNyZWF0ZWQuIENhbiBiZSAnbnVtYmVyJywgJ2J1bGxldCcsIG9yICdjaGVjaycuXG4gKiBAcGFyYW0gc3RhcnQgLSBXaGVyZSBhbiBvcmRlcmVkIGxpc3Qgc3RhcnRzIGl0cyBjb3VudCwgc3RhcnQgPSAxIGlmIGxlZnQgdW5kZWZpbmVkLlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0Tm9kZVxuICovXG5mdW5jdGlvbiAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUgPSAnbnVtYmVyJywgc3RhcnQgPSAxKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpc3ROb2RlKGxpc3RUeXBlLCBzdGFydCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0Tm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0Tm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNMaXN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTGlzdE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQnKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hlY2tMaXN0KGVkaXRvcikge1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQsICgpID0+IHtcbiAgICAkaW5zZXJ0TGlzdCgnY2hlY2snKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICByZXR1cm4gaGFuZGxlQXJyb3dVcE9yRG93bihldmVudCwgZWRpdG9yLCBmYWxzZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIHJldHVybiBoYW5kbGVBcnJvd1VwT3JEb3duKGV2ZW50LCBlZGl0b3IsIHRydWUpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0VTQ0FQRV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcbiAgICBpZiAoYWN0aXZlSXRlbSAhPSBudWxsKSB7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgICAgaWYgKHJvb3RFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfU1BBQ0VfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG4gICAgaWYgKGFjdGl2ZUl0ZW0gIT0gbnVsbCAmJiBlZGl0b3IuaXNFZGl0YWJsZSgpKSB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoYWN0aXZlSXRlbSk7XG4gICAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobGlzdEl0ZW1Ob2RlKSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgbGlzdEl0ZW1Ob2RlLnRvZ2dsZUNoZWNrZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIHJldHVybiBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhbmNob3JcbiAgICAgICAgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgaXNFbGVtZW50ID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JztcbiAgICAgICAgaWYgKGlzRWxlbWVudCB8fCBhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgY29uc3QgZWxlbWVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsIG5vZGUgPT4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSk7XG4gICAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShlbGVtZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnROb2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkgJiYgcGFyZW50LmdldExpc3RUeXBlKCkgPT09ICdjaGVjaycgJiYgKGlzRWxlbWVudCB8fCBlbGVtZW50Tm9kZS5nZXRGaXJzdERlc2NlbmRhbnQoKSA9PT0gYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgZG9tTm9kZSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWxlbWVudE5vZGUuX19rZXkpO1xuICAgICAgICAgICAgICBpZiAoZG9tTm9kZSAhPSBudWxsICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcigocm9vdEVsZW1lbnQsIHByZXZFbGVtZW50KSA9PiB7XG4gICAgaWYgKHJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcbiAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgIH1cbiAgICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHByZXZFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgcHJldkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgfVxuICB9KSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDaGVja0l0ZW1FdmVudChldmVudCwgY2FsbGJhY2spIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBpZiAoIWlzSFRNTEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElnbm9yZSBjbGlja3Mgb24gTEkgdGhhdCBoYXZlIG5lc3RlZCBsaXN0c1xuICBjb25zdCBmaXJzdENoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gIGlmIChpc0hUTUxFbGVtZW50KGZpcnN0Q2hpbGQpICYmIChmaXJzdENoaWxkLnRhZ05hbWUgPT09ICdVTCcgfHwgZmlyc3RDaGlsZC50YWdOYW1lID09PSAnT0wnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJlbnROb2RlID0gdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBmaWVsZFxuICBpZiAoIXBhcmVudE5vZGUgfHwgcGFyZW50Tm9kZS5fX2xleGljYWxMaXN0VHlwZSAhPT0gJ2NoZWNrJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB6b29tID0gY2FsY3VsYXRlWm9vbUxldmVsKHRhcmdldCk7XG4gIGNvbnN0IGNsaWVudFggPSBldmVudC5jbGllbnRYIC8gem9vbTtcblxuICAvLyBVc2UgZ2V0Q29tcHV0ZWRTdHlsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsYmFjayB0byAwcHggd2lkdGhcbiAgY29uc3QgYmVmb3JlU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsICc6OmJlZm9yZScpIDoge1xuICAgIHdpZHRoOiAnMHB4J1xuICB9O1xuICBjb25zdCBiZWZvcmVXaWR0aEluUGl4ZWxzID0gcGFyc2VGbG9hdChiZWZvcmVTdHlsZXMud2lkdGgpO1xuXG4gIC8vIE1ha2UgY2xpY2sgYXJlYSBzbGlnaHRseSBsYXJnZXIgZm9yIHRvdWNoIGRldmljZXMgdG8gaW1wcm92ZSBhY2Nlc3NpYmlsaXR5XG4gIGNvbnN0IGlzVG91Y2hFdmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xuICBjb25zdCBjbGlja0FyZWFQYWRkaW5nID0gaXNUb3VjaEV2ZW50ID8gMzIgOiAwOyAvLyBBZGQgMzJweCBwYWRkaW5nIGZvciB0b3VjaCBldmVudHNcblxuICBpZiAodGFyZ2V0LmRpciA9PT0gJ3J0bCcgPyBjbGllbnRYIDwgcmVjdC5yaWdodCArIGNsaWNrQXJlYVBhZGRpbmcgJiYgY2xpZW50WCA+IHJlY3QucmlnaHQgLSBiZWZvcmVXaWR0aEluUGl4ZWxzIC0gY2xpY2tBcmVhUGFkZGluZyA6IGNsaWVudFggPiByZWN0LmxlZnQgLSBjbGlja0FyZWFQYWRkaW5nICYmIGNsaWVudFggPCByZWN0LmxlZnQgKyBiZWZvcmVXaWR0aEluUGl4ZWxzICsgY2xpY2tBcmVhUGFkZGluZykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gIGhhbmRsZUNoZWNrSXRlbUV2ZW50KGV2ZW50LCAoKSA9PiB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgY29uc3QgZG9tTm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZShkb21Ob2RlKTtcbiAgICAgIGlmIChlZGl0b3IgIT0gbnVsbCAmJiBlZGl0b3IuaXNFZGl0YWJsZSgpKSB7XG4gICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShkb21Ob2RlKTtcbiAgICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBkb21Ob2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBub2RlLnRvZ2dsZUNoZWNrZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bihldmVudCkge1xuICBoYW5kbGVDaGVja0l0ZW1FdmVudChldmVudCwgKCkgPT4ge1xuICAgIC8vIFByZXZlbnRzIGNhcmV0IG1vdmluZyB3aGVuIGNsaWNraW5nIG9uIGNoZWNrIG1hcmtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKSB7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChhY3RpdmVFbGVtZW50KSAmJiBhY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdMSScgJiYgYWN0aXZlRWxlbWVudC5wYXJlbnROb2RlICE9IG51bGwgJiZcbiAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBmaWVsZFxuICBhY3RpdmVFbGVtZW50LnBhcmVudE5vZGUuX19sZXhpY2FsTGlzdFR5cGUgPT09ICdjaGVjaycgPyBhY3RpdmVFbGVtZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRDaGVja0xpc3RJdGVtU2libGluZyhub2RlLCBiYWNrd2FyZCkge1xuICBsZXQgc2libGluZyA9IGJhY2t3YXJkID8gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG5cbiAgLy8gR29pbmcgdXAgaW4gYSB0cmVlIHRvIGdldCBub24tbnVsbCBzaWJsaW5nXG4gIHdoaWxlIChzaWJsaW5nID09IG51bGwgJiYgJGlzTGlzdEl0ZW1Ob2RlKHBhcmVudCkpIHtcbiAgICAvLyBHZXQgbGkgLT4gcGFyZW50IHVsL29sIC0+IHBhcmVudCBsaVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCkuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gIH1cblxuICAvLyBHb2luZyBkb3duIGluIGEgdHJlZSB0byBnZXQgZmlyc3Qgbm9uLW5lc3RlZCBsaXN0IGl0ZW1cbiAgd2hpbGUgKCRpc0xpc3RJdGVtTm9kZShzaWJsaW5nKSkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBiYWNrd2FyZCA/IHNpYmxpbmcuZ2V0TGFzdENoaWxkKCkgOiBzaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gc2libGluZztcbiAgICB9XG4gICAgc2libGluZyA9IGJhY2t3YXJkID8gZmlyc3RDaGlsZC5nZXRMYXN0Q2hpbGQoKSA6IGZpcnN0Q2hpbGQuZ2V0Rmlyc3RDaGlsZCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaGFuZGxlQXJyb3dVcE9yRG93bihldmVudCwgZWRpdG9yLCBiYWNrd2FyZCkge1xuICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpO1xuICBpZiAoYWN0aXZlSXRlbSAhPSBudWxsKSB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0SXRlbSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGFjdGl2ZUl0ZW0pO1xuICAgICAgaWYgKCEkaXNMaXN0SXRlbU5vZGUobGlzdEl0ZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRMaXN0SXRlbSA9IGZpbmRDaGVja0xpc3RJdGVtU2libGluZyhsaXN0SXRlbSwgYmFja3dhcmQpO1xuICAgICAgaWYgKG5leHRMaXN0SXRlbSAhPSBudWxsKSB7XG4gICAgICAgIG5leHRMaXN0SXRlbS5zZWxlY3RTdGFydCgpO1xuICAgICAgICBjb25zdCBkb20gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5leHRMaXN0SXRlbS5fX2tleSk7XG4gICAgICAgIGlmIChkb20gIT0gbnVsbCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkb20uZm9jdXMoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBVUERBVEVfTElTVF9TVEFSVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnVVBEQVRFX0xJU1RfU1RBUlRfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5EJyk7XG5jb25zdCBSRU1PVkVfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnUkVNT1ZFX0xJU1RfQ09NTUFORCcpO1xuZnVuY3Rpb24gcmVnaXN0ZXJMaXN0KGVkaXRvcikge1xuICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQsICgpID0+IHtcbiAgICAkaW5zZXJ0TGlzdCgnbnVtYmVyJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChVUERBVEVfTElTVF9TVEFSVF9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsaXN0Tm9kZUtleSxcbiAgICAgIG5ld1N0YXJ0XG4gICAgfSA9IHBheWxvYWQ7XG4gICAgY29uc3QgbGlzdE5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGxpc3ROb2RlS2V5KTtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3ROb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGlzdE5vZGUuZ2V0TGlzdFR5cGUoKSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxpc3ROb2RlLnNldFN0YXJ0KG5ld1N0YXJ0KTtcbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShsaXN0Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQsICgpID0+IHtcbiAgICAkaW5zZXJ0TGlzdCgnYnVsbGV0Jyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChSRU1PVkVfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJHJlbW92ZUxpc3QoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgKCkgPT4gJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgoKSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKExpc3RJdGVtTm9kZSwgbm9kZSA9PiB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBmaXJzdENoaWxkLmdldFN0eWxlKCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGZpcnN0Q2hpbGQuZ2V0Rm9ybWF0KCk7XG4gICAgICAgIGlmIChub2RlLmdldFRleHRTdHlsZSgpICE9PSBzdHlsZSkge1xuICAgICAgICAgIG5vZGUuc2V0VGV4dFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5nZXRUZXh0Rm9ybWF0KCkgIT09IGZvcm1hdCkge1xuICAgICAgICAgIG5vZGUuc2V0VGV4dEZvcm1hdChmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3MgZW1wdHksIGNoZWNrIHRoZSBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIChzZWxlY3Rpb24uc3R5bGUgIT09IG5vZGUuZ2V0VGV4dFN0eWxlKCkgfHwgc2VsZWN0aW9uLmZvcm1hdCAhPT0gbm9kZS5nZXRUZXh0Rm9ybWF0KCkpICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIG5vZGUuaXMoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpKSB7XG4gICAgICAgIG5vZGUuc2V0VGV4dFN0eWxlKHNlbGVjdGlvbi5zdHlsZSkuc2V0VGV4dEZvcm1hdChzZWxlY3Rpb24uZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRleHROb2RlLCBub2RlID0+IHtcbiAgICBjb25zdCBsaXN0SXRlbVBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobGlzdEl0ZW1QYXJlbnROb2RlKSAmJiBub2RlLmlzKGxpc3RJdGVtUGFyZW50Tm9kZS5nZXRGaXJzdENoaWxkKCkpKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IG5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICBpZiAoc3R5bGUgIT09IGxpc3RJdGVtUGFyZW50Tm9kZS5nZXRUZXh0U3R5bGUoKSB8fCBmb3JtYXQgIT09IGxpc3RJdGVtUGFyZW50Tm9kZS5nZXRUZXh0Rm9ybWF0KCkpIHtcbiAgICAgICAgbGlzdEl0ZW1QYXJlbnROb2RlLnNldFRleHRTdHlsZShzdHlsZSkuc2V0VGV4dEZvcm1hdChmb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xuICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG59XG5mdW5jdGlvbiByZWdpc3Rlckxpc3RTdHJpY3RJbmRlbnRUcmFuc2Zvcm0oZWRpdG9yKSB7XG4gIGNvbnN0ICRmb3JtYXRMaXN0SW5kZW50U3RyaWN0ID0gbGlzdEl0ZW1Ob2RlID0+IHtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IGxpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUobGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKSkgfHwgISRpc0xpc3ROb2RlKGxpc3ROb2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydGluZ0xpc3RJdGVtTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobGlzdEl0ZW1Ob2RlLCBub2RlID0+ICRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAkaXNMaXN0Tm9kZShub2RlLmdldFBhcmVudCgpKSAmJiAkaXNMaXN0SXRlbU5vZGUobm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSkpO1xuICAgIGlmIChzdGFydGluZ0xpc3RJdGVtTm9kZSA9PT0gbnVsbCAmJiBsaXN0SXRlbU5vZGUuZ2V0SW5kZW50KCkgPiAwKSB7XG4gICAgICBsaXN0SXRlbU5vZGUuc2V0SW5kZW50KDApO1xuICAgIH0gZWxzZSBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHN0YXJ0aW5nTGlzdEl0ZW1Ob2RlKSkge1xuICAgICAgY29uc3QgcHJldkxpc3RJdGVtTm9kZSA9IHN0YXJ0aW5nTGlzdEl0ZW1Ob2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShwcmV2TGlzdEl0ZW1Ob2RlKSkge1xuICAgICAgICBjb25zdCBlbmRMaXN0SXRlbU5vZGUgPSAkZmluZENoaWxkcmVuRW5kTGlzdEl0ZW1Ob2RlKHByZXZMaXN0SXRlbU5vZGUpO1xuICAgICAgICBjb25zdCBlbmRMaXN0Tm9kZSA9IGVuZExpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGVuZExpc3ROb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZEZXB0aCA9ICRnZXRMaXN0RGVwdGgoZW5kTGlzdE5vZGUpO1xuICAgICAgICAgIGNvbnN0IGRlcHRoID0gJGdldExpc3REZXB0aChsaXN0Tm9kZSk7XG4gICAgICAgICAgaWYgKHByZXZEZXB0aCArIDEgPCBkZXB0aCkge1xuICAgICAgICAgICAgbGlzdEl0ZW1Ob2RlLnNldEluZGVudChwcmV2RGVwdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgJHByb2Nlc3NMaXN0V2l0aFN0cmljdEluZGVudCA9IGxpc3ROb2RlID0+IHtcbiAgICBjb25zdCBxdWV1ZSA9IFtsaXN0Tm9kZV07XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgaWYgKCEkaXNMaXN0Tm9kZShub2RlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5nZXRDaGlsZHJlbigpKSB7XG4gICAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgJGZvcm1hdExpc3RJbmRlbnRTdHJpY3QoY2hpbGQpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBjaGlsZC5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oTGlzdE5vZGUsICRwcm9jZXNzTGlzdFdpdGhTdHJpY3RJbmRlbnQpO1xufVxuZnVuY3Rpb24gJGZpbmRDaGlsZHJlbkVuZExpc3RJdGVtTm9kZShsaXN0SXRlbU5vZGUpIHtcbiAgbGV0IGN1cnJlbnQgPSBsaXN0SXRlbU5vZGU7XG4gIGxldCBmaXJzdENoaWxkID0gY3VycmVudC5nZXRGaXJzdENoaWxkKCk7XG4gIHdoaWxlICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IGZpcnN0Q2hpbGQuZ2V0TGFzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShsYXN0Q2hpbGQpKSB7XG4gICAgICBjdXJyZW50ID0gbGFzdENoaWxkO1xuICAgICAgZmlyc3RDaGlsZCA9IGN1cnJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayAkaW5zZXJ0TGlzdH0gZnJvbSBhbiB1cGRhdGUgb3IgY29tbWFuZCBsaXN0ZW5lci5cbiAqXG4gKiBJbnNlcnRzIGEgbmV3IExpc3ROb2RlLiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlIGFuZCBpcyBhIGNoaWxkIG9mXG4gKiB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCByZXBsYWNlIHRoZSBMaXN0SXRlbU5vZGUgd2l0aCBhIExpc3ROb2RlIGFuZCB0aGUgb2xkIExpc3RJdGVtTm9kZS5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHJlcGxhY2UgaXRzIHBhcmVudCB3aXRoIGEgbmV3IExpc3ROb2RlIGFuZCByZS1pbnNlcnQgdGhlIExpc3RJdGVtTm9kZSBhbmQgYW55IHByZXZpb3VzIGNoaWxkcmVuLlxuICogSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIG5vdCBhbiBlbXB0eSBMaXN0SXRlbU5vZGUsIGl0IHdpbGwgYWRkIGEgbmV3IExpc3ROb2RlIG9yIG1lcmdlIGFuIGV4aXN0aW5nIExpc3ROb2RlLFxuICogdW5sZXNzIHRoZSB0aGUgbm9kZSBpcyBhIGxlYWYgbm9kZSwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIExpc3ROb2RlIHVwIHRoZSBicmFuY2ggYW5kIHJlcGxhY2UgaXQgd2l0aFxuICogYSBuZXcgTGlzdE5vZGUsIG9yIGNyZWF0ZSBhIG5ldyBMaXN0Tm9kZSBhdCB0aGUgbmVhcmVzdCByb290L3NoYWRvdyByb290LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBsaXN0VHlwZSAtIFRoZSB0eXBlIG9mIGxpc3QsIFwibnVtYmVyXCIgfCBcImJ1bGxldFwiIHwgXCJjaGVja1wiLlxuICovXG5mdW5jdGlvbiBpbnNlcnRMaXN0KGVkaXRvciwgbGlzdFR5cGUpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiAkaW5zZXJ0TGlzdChsaXN0VHlwZSkpO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgJHJlbW92ZUxpc3R9IGZyb20gYW4gdXBkYXRlIG9yIGNvbW1hbmQgbGlzdGVuZXIuXG4gKlxuICogU2VhcmNoZXMgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmVtb3ZlcyBpdC4gSWYgc2VsZWN0aW9uIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZVxuICogaXQgd2lsbCByZW1vdmUgdGhlIHdob2xlIGxpc3QsIGluY2x1ZGluZyB0aGUgTGlzdEl0ZW1Ob2RlLiBGb3IgZWFjaCBMaXN0SXRlbU5vZGUgaW4gdGhlIExpc3ROb2RlLFxuICogcmVtb3ZlTGlzdCB3aWxsIGFsc28gZ2VuZXJhdGUgbmV3IFBhcmFncmFwaE5vZGVzIGluIHRoZSByZW1vdmVkIExpc3ROb2RlJ3MgcGxhY2UuIEFueSBjaGlsZCBub2RlXG4gKiBpbnNpZGUgYSBMaXN0SXRlbU5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgbmV3IFBhcmFncmFwaE5vZGVzLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdChlZGl0b3IpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiAkcmVtb3ZlTGlzdCgpKTtcbn1cblxuZXhwb3J0IHsgJGNyZWF0ZUxpc3RJdGVtTm9kZSwgJGNyZWF0ZUxpc3ROb2RlLCAkZ2V0TGlzdERlcHRoLCAkaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaCwgJGluc2VydExpc3QsICRpc0xpc3RJdGVtTm9kZSwgJGlzTGlzdE5vZGUsICRyZW1vdmVMaXN0LCBJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5ELCBJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQsIElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5ELCBMaXN0SXRlbU5vZGUsIExpc3ROb2RlLCBSRU1PVkVfTElTVF9DT01NQU5ELCBVUERBVEVfTElTVF9TVEFSVF9DT01NQU5ELCBpbnNlcnRMaXN0LCByZWdpc3RlckNoZWNrTGlzdCwgcmVnaXN0ZXJMaXN0LCByZWdpc3Rlckxpc3RTdHJpY3RJbmRlbnRUcmFuc2Zvcm0sIHJlbW92ZUxpc3QgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs\n",
      )

      /***/
    },
}
